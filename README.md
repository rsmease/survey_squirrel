# README

## The Prompt

Please use Rails to build a simple survey tool, with the following requirements:
* A user should be able to create any number of surveys
* A survey consists of one question represented as a single string. The answer to the question is always Yes or No.
* The home screen of your app should show a list of surveys and a button to create a new one
* You don't need to worry about user authentication but you may stub this out if you wish
* A user can respond to a survey by clicking into it from the list mentioned above
* A survey can be answered multiple times with a yes/no response
* You should keep track of when each of the survey responses are saved
* You should display the results of the survey on the home screen with the percentage of yes and no responses.
* You should make sure that your app can be run by other developers on the team.
* Make sure all of your dependencies are listed in your Gemfile and instructions are provided for setup if needed.
* You should use SQLite to persist your data.

## Introductory Notes

Survey Squirrel is a survey tool used to generate simple, single-question surveys with yes/no answers. You can boot the program locally by running the following commands from the main project directory:

```
bundle install
npm install
rails db:setup
rails db:seed
rails s
webpack --watch
```

If you are developing locally, I would recommend runinng the Rails server and Webpack commands in separate windows, so that you can review both of them to trace bugs during development.

## Back-End

### Introduction

The backend is a good old-fashioned Rails server with a SQLite database. The backend passes data to the React/Redux frontend using JSON, unlocking a single-page app look and feel.

### Models

There are three models used by the application to store surveys and their response data. The User model represents registered visitors to the site. The Survey model represents simple, one-question surveys. A Survey can be generated by a registered user or an anonymous visitor. The SurveyResponse model represents responses to a specific Survey instance. SurveyResponses may or may not be associated with a registered User. There is no limit to the number of responses that a visitor can make on a given Survey. Timestamps are kept to track the time that all surveys are created, and the time that all survey responses are submitted.

### Controllers

The primary controllers map to the models describe above. They are all namespaced under API to emphasize that their primary role is to pass JSON to the React frontend, and not to delivery HTML (ERB/HAML) views, like what we'd see in a typical server-side rendering setup. The views are simple JBuilder documents that can be passed to queries made by the application's frontend. The controllers use the strong params pattern to guard against SQL injection.

The other noteworthy controller is the ReactController, which serves as a gateway to an ERB file that renders a DOM root for the React app to hold onto.

I had plans for generating a SessionController that would track the session state and the current user. See the section below for more information on the draft-only state of user authentication.

### Testing

There are tests on all models and all model-associated controllers. You can run them by simply typing `rspec` into the terminal while you're in the main directory. I used RSpec and Shoulda Matchers to construct the tests. The tests are mostly what I would describe as "happy path" tests, the kind of simple, semantic tests that serve as documentation. These tests would be more vaulable if they were expanded to include various edge cases and business-driven scenarios.

### User Authentication

Currently, the user authenticaiton feauture is only drafted. I have the User model and controller in place to enable this feature. I would create a separate SessionController to track user sessions separately, so that I can do things like 'log in a current user, but show that user all of the other users that are online.' With this pattern, the client would only have on session and one current user, but it could recognize many others users. I held off from fully implementing the feature due to time constraints. If you would like to see it in action, just let me know and I'll update this repository to get it working on the frontend. The work remaining would look like:
1. Add a registration/login form to the frontend to generate new users and sessions
2. Allow the Redux cycle to receive information about the presence of the current user
3. Tag Surveys and SurveyResponses created by the current user with the current user's ID (Survey already has a surveyor_id, but SurveyReponse would need a migration to add responder_id)
4. Add some kind of UI affordance that made it clear who created each survey
5. Add a logout button and allow sessions to be terminated

## Front-End

### Introduction

The frontend is a React app with a Redux store. Data is passed from the controllers to the Redux store, which thoughtfully re-renders only those components whose internally state will need to change as a result of the updated store. If a component does not care about a particular slice of state, we won't have to pay the render tax for that component, improving global application performance.

### Data Flow

The Redux store is designed to create a pure model for data flow from the backend to React components. Updated sections of state are removed and replaced (rather than mutated) when underlying state is changed. The util files have a bunch of HTTP callbacks that hit the Rails controllers. The actions files specify callback functions that can be called by React components. These actions are structured as thunks so that they fold into the Redux `dispatch` pattern. The reducer files delete and replace sections of global state, which trigger re-renders in the appropriate components. Components are typically wrapped in Redux container functions, which enable the selective re-rendering by subscribing components to specific slices of global state that are relevant to their local state. The container functions also pass along action callbacks to components that will want to trigger them.

### React Components

The React components are structured in a  `container -> index -> indexItem`  nesting pattern. The main view of the app features the `SurveyIndex`, which includes all of the surveys available to visitors. Clicking on a survey lets you post SurveyResponse instances, and the results of the survey are updated automatically as you click the response buttons. The frontend is built using a Bootstrap grid and a few other core Bootstrap components.

### Performance

You should notice a loading animation show up the first time that you load the app. In order to simulate latency, I added a two-second timeout to the initial load so that you can see what the loading screen would look like if you were somewhere that didn't have fast internet. Without that timeout, the app was loading instantly and you couldn't appreciate the loading animation! At scale, we could speed up the app using these techniques:
1. If a user is submitting a bunch of responses, collect them within the client and send them off as a batch request at certain intervals. We could still simulate the changes on the client by updating the yes/no count and the percentage bar.
2. Find a more thoughtful way to track the count of yes and no responses to questions within the database. At the moment, I can calculating them live via Rails association every time I pull a survey out of the database, which would slow things down if there were millions of responses to count. That's fine for now, since we only make that call one time per session, but it's something to think about.

### Testing

Current, there are no integration tests. If you would like me to add some, let me know. I would likely use Capybara, although I have also had great experience with new Cypress testing library. Here's an exmaple what I would test:
1. Do all of the surveys render on the homepage?
2. Do I get immediate visual feedback to survey responses?
3. When I fail to create a survey correctly, are errors displayed?
4. When I correctly correct a survey after errors are display, do errors disappear?
5. When I create a survey, does the modal close as expected?
6. Do I encounter any friction if I try to respond to the same survey multiple times?

### Some Ways to Improve the UI

Here are some things that I would have added to the UI with more time:
1. User authentication forms
2. More guardrails for inputs -- e.g. I don't force users to type and actual question and I don't guard against vulgar language
3. The mobile experience is just OK

### Credits

Thanks to https://www.freepik.com for the acorn icon.
Thanks to Codepen user sdthornton for the box shadows on the SurveyIndexItem cards.
Thanks for Apple for the opportunity!

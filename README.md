# README

- Notes to add:
- user model, controller
- JSON namespacing
- testing procedures

## The Prompt

Please use Rails to build a simple survey tool, with the following requirements:
* A user should be able to create any number of surveys
* A survey consists of one question represented as a single string. The answer to the question is always Yes or No.
* The home screen of your app should show a list of surveys and a button to create a new one
* You don't need to worry about user authentication but you may stub this out if you wish
* A user can respond to a survey by clicking into it from the list mentioned above
* A survey can be answered multiple times with a yes/no response
* You should keep track of when each of the survey responses are saved
* You should display the results of the survey on the home screen with the percentage of yes and no responses.
* You should make sure that your app can be run by other developers on the team.
* Make sure all of your dependencies are listed in your Gemfile and instructions are provided for setup if needed.
* You should use SQLite to persist your data.

## Introductory Notes

Survey Squirrel is a survey tool used to generate simple, single-question surveys with yes/no answers. You can boot the program locally by running the following commands from the main project directory:

```
bundle install
rails db:seed
rails s
webpack --watch
```

If you are developing locally, I would recommend runinng the Rails server and Webpack commands in separate windows, so that you can both of them to trace bugs during development.

## Back-End

### Introduction

The backend is a good old-fashioned Rails server with a SQLite database. The backend passes data to the React/Redux frontend using JSON, unlocking a single-page app look and feel.

### Models

There are three models used by the application to store surveys and their response data. The User model represented registered visitors to the site. The Survey model represents simple, one-question surveys. A Survey can be generated by a registered user or an anonymous visitor. The SurveyResponse model represents responses to a specific Survey instance. SurveyResponses may or may not be associated with a registered User. There is no limit to the number of responses that a visitor can make on a given Survey. Timestamps are kept to track the time that all surveys are created, and the time that all survey responses are submitted.

### Controllers

The primary controllers map to the models describe above. They are all namespaced under API to emphasize that their primary role is to pass JSON to the React frontend, and not to delivery HTML (ERB/HAML) views, like what we'd see in a typical server-side rendering setup. The views are simple JBuilder documents that can be passed to queries made by the application's frontend. The controllers use the strong params pattern to guard against SQL injection.

The other noteworthy controller is the ReactController, which just serves as a gateway to an ERB file that renders a DOM root for the React app to grab a hold on.

I had plans for generating a SessionController that would track the session state and the current user. See the section below for more information on user authentication.

### Testing

There are tests on all models and all model-associated controllers. You can run them by simply typing `rspec` into the terminal. I used RSpec and ShouldaMatchers to construct the tests. The tests are mostly what I would describe as "happy path" tests, the kind of simple, semantic tests that serve as documentation. These tests would be more vaulable if they were expanded to include various edge cases and business-driven scenarios.

### User Authentication

Currently, the user authenticaiton feauture is only drafted. I have the User model and controller in place to enable this feature. I would create a separate SessionController to track user sessions separately, so that I can do things like 'log in a current user, but show that users all the other users that are online.' With this pattern, the client would only have on session and one current user, but it could recognize many others users. I held off from fully implementing the feature due to time constraints. If you would like to see it in action, just let me know and I'll update this repository to get it working on the frontend. The work remaining would look like:
1. Add a registration/login form to the frontend to generate new users and sessions
2. Allow the Redux cycle to receive information about the presence of the current user
3. Tag Surveys and SurveyResponses created by the current user with the current user's ID (Survey already has a surveyor_id, but SurveyReponse would need a migration to add responder_id)
4. Add some kind of UI affordance that made it clear who created each survey
5. Add a logout button and allow sessions to be terminated

## Front-End

### Introduction

The frontend is a React app with a Redux store. Data is passed from the controllers to the Redux store, which thoughtfully re-renders only those components whos internally state will need to change as a result of the updated store. If a component does not care about a particular slice of state, we won't have to pay the render tax for that component, improving global application performance.

### Data Flow

The Redux store is designed to create a pure model for data flow from the backend to React components. Updated sections of state are removed and replaced (rather than mutated) when underlying state is changed. The util files include asynchronous calls to the backend with HTTP methods. The actions files specify specific asyncronous functions that can be called by React components. These actions are structured as thunks so that they fold into the Redux `dispatch` pattern. The reducer files delete and replace sections of global state, which trigger re-renders in the appropriate components. Components are typically wrapped in Redux container functions, which eanble this smart re-rendering by subscribing components to specific slices of state that are relevant to their contents. The contaienr functions also pass along action callbacks to components that will want to trigger them.

### React Components

The React components are structured in a  `container -> index -> indexItem`  nesting pattern. The main view of the app features the `SurveyIndex`, which includes all of the surveys available to visitors. Clicking on a survey lets you post SurveyResponse instances, and the results of the survey are updated automatically as you click the response buttons. The frontend is build using a Bootstrap grid and a few other core Bootstrap components.

### Testing

Current, there are no integration tests. If you would like me to add some, let me know. I would likely use Capybara, although I have also had great experience with new Cypress testing library. Here's an exmaple what I would test:
1. Do all of the surveys render on the homepage?
2. Do I get immediate feedback to survey responses?
3. When I fail to create a survey correctly, are errors displayed?
4. When I correctly correct a survey after errors are display, do errors disappear?
5. When I create a survey, does the modal close as expected?
6. Do I encounter any friction if I try to respond to the same survey multiple times?
